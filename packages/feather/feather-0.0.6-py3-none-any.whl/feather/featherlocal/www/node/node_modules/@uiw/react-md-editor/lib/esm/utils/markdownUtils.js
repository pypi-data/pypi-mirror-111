import getSurroundingWord from './getSurroundingWord';
export function selectWord(_ref) {
  var text = _ref.text,
      selection = _ref.selection;

  if (text && text.length && selection.start === selection.end) {
    // the user is pointing to a word
    return getSurroundingWord(text, selection.start);
  }

  return selection;
}
/**
 *  Gets the number of line-breaks that would have to be inserted before the given 'startPosition'
 *  to make sure there's an empty line between 'startPosition' and the previous text
 */

export function getBreaksNeededForEmptyLineBefore() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var startPosition = arguments.length > 1 ? arguments[1] : undefined;
  if (startPosition === 0) return 0; // rules:
  // - If we're in the first line, no breaks are needed
  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we
  //      may need to insert 0, 1 or 2 breaks

  var neededBreaks = 2;
  var isInFirstLine = true;

  for (var i = startPosition - 1; i >= 0 && neededBreaks >= 0; i--) {
    switch (text.charCodeAt(i)) {
      case 32:
        // blank space
        continue;

      case 10:
        // line break
        neededBreaks--;
        isInFirstLine = false;
        break;

      default:
        return neededBreaks;
    }
  }

  return isInFirstLine ? 0 : neededBreaks;
}
/**
 *  Gets the number of line-breaks that would have to be inserted after the given 'startPosition'
 *  to make sure there's an empty line between 'startPosition' and the next text
 */

export function getBreaksNeededForEmptyLineAfter() {
  var text = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
  var startPosition = arguments.length > 1 ? arguments[1] : undefined;
  if (startPosition === text.length - 1) return 0; // rules:
  // - If we're in the first line, no breaks are needed
  // - Otherwise there must be 2 breaks before the previous character. Depending on how many breaks exist already, we
  //      may need to insert 0, 1 or 2 breaks

  var neededBreaks = 2;
  var isInLastLine = true;

  for (var i = startPosition; i < text.length && neededBreaks >= 0; i++) {
    switch (text.charCodeAt(i)) {
      case 32:
        continue;

      case 10:
        {
          neededBreaks--;
          isInLastLine = false;
          break;
        }

      default:
        return neededBreaks;
    }
  }

  return isInLastLine ? 0 : neededBreaks;
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy91dGlscy9tYXJrZG93blV0aWxzLnRzIl0sIm5hbWVzIjpbImdldFN1cnJvdW5kaW5nV29yZCIsInNlbGVjdFdvcmQiLCJ0ZXh0Iiwic2VsZWN0aW9uIiwibGVuZ3RoIiwic3RhcnQiLCJlbmQiLCJnZXRCcmVha3NOZWVkZWRGb3JFbXB0eUxpbmVCZWZvcmUiLCJzdGFydFBvc2l0aW9uIiwibmVlZGVkQnJlYWtzIiwiaXNJbkZpcnN0TGluZSIsImkiLCJjaGFyQ29kZUF0IiwiZ2V0QnJlYWtzTmVlZGVkRm9yRW1wdHlMaW5lQWZ0ZXIiLCJpc0luTGFzdExpbmUiXSwibWFwcGluZ3MiOiJBQUNBLE9BQU9BLGtCQUFQLE1BQStCLHNCQUEvQjtBQU9BLE9BQU8sU0FBU0MsVUFBVCxPQUFpRTtBQUFBLE1BQTNDQyxJQUEyQyxRQUEzQ0EsSUFBMkM7QUFBQSxNQUFyQ0MsU0FBcUMsUUFBckNBLFNBQXFDOztBQUN0RSxNQUFJRCxJQUFJLElBQUlBLElBQUksQ0FBQ0UsTUFBYixJQUF1QkQsU0FBUyxDQUFDRSxLQUFWLEtBQW9CRixTQUFTLENBQUNHLEdBQXpELEVBQThEO0FBQzVEO0FBQ0EsV0FBT04sa0JBQWtCLENBQUNFLElBQUQsRUFBT0MsU0FBUyxDQUFDRSxLQUFqQixDQUF6QjtBQUNEOztBQUNELFNBQU9GLFNBQVA7QUFDRDtBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUNBLE9BQU8sU0FBU0ksaUNBQVQsR0FBcUY7QUFBQSxNQUExQ0wsSUFBMEMsdUVBQW5DLEVBQW1DO0FBQUEsTUFBL0JNLGFBQStCO0FBQzFGLE1BQUlBLGFBQWEsS0FBSyxDQUF0QixFQUF5QixPQUFPLENBQVAsQ0FEaUUsQ0FHMUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSUMsWUFBWSxHQUFHLENBQW5CO0FBQ0EsTUFBSUMsYUFBYSxHQUFHLElBQXBCOztBQUNBLE9BQUssSUFBSUMsQ0FBQyxHQUFHSCxhQUFhLEdBQUcsQ0FBN0IsRUFBZ0NHLENBQUMsSUFBSSxDQUFMLElBQVVGLFlBQVksSUFBSSxDQUExRCxFQUE2REUsQ0FBQyxFQUE5RCxFQUFrRTtBQUNoRSxZQUFRVCxJQUFJLENBQUNVLFVBQUwsQ0FBZ0JELENBQWhCLENBQVI7QUFDRSxXQUFLLEVBQUw7QUFBUztBQUNQOztBQUNGLFdBQUssRUFBTDtBQUFTO0FBQ1BGLFFBQUFBLFlBQVk7QUFDWkMsUUFBQUEsYUFBYSxHQUFHLEtBQWhCO0FBQ0E7O0FBQ0Y7QUFDRSxlQUFPRCxZQUFQO0FBUko7QUFVRDs7QUFDRCxTQUFPQyxhQUFhLEdBQUcsQ0FBSCxHQUFPRCxZQUEzQjtBQUNEO0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBQ0EsT0FBTyxTQUFTSSxnQ0FBVCxHQUFvRjtBQUFBLE1BQTFDWCxJQUEwQyx1RUFBbkMsRUFBbUM7QUFBQSxNQUEvQk0sYUFBK0I7QUFDekYsTUFBSUEsYUFBYSxLQUFLTixJQUFJLENBQUNFLE1BQUwsR0FBYyxDQUFwQyxFQUF1QyxPQUFPLENBQVAsQ0FEa0QsQ0FHekY7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsTUFBSUssWUFBWSxHQUFHLENBQW5CO0FBQ0EsTUFBSUssWUFBWSxHQUFHLElBQW5COztBQUNBLE9BQUssSUFBSUgsQ0FBQyxHQUFHSCxhQUFiLEVBQTRCRyxDQUFDLEdBQUdULElBQUksQ0FBQ0UsTUFBVCxJQUFtQkssWUFBWSxJQUFJLENBQS9ELEVBQWtFRSxDQUFDLEVBQW5FLEVBQXVFO0FBQ3JFLFlBQVFULElBQUksQ0FBQ1UsVUFBTCxDQUFnQkQsQ0FBaEIsQ0FBUjtBQUNFLFdBQUssRUFBTDtBQUNFOztBQUNGLFdBQUssRUFBTDtBQUFTO0FBQ1BGLFVBQUFBLFlBQVk7QUFDWkssVUFBQUEsWUFBWSxHQUFHLEtBQWY7QUFDQTtBQUNEOztBQUNEO0FBQ0UsZUFBT0wsWUFBUDtBQVRKO0FBV0Q7O0FBQ0QsU0FBT0ssWUFBWSxHQUFHLENBQUgsR0FBT0wsWUFBMUI7QUFDRCIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFRleHRSYW5nZSB9IGZyb20gJy4uL2NvbW1hbmRzJztcbmltcG9ydCBnZXRTdXJyb3VuZGluZ1dvcmQgZnJvbSAnLi9nZXRTdXJyb3VuZGluZ1dvcmQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIFRleHRTZWN0aW9uIHtcbiAgdGV4dDogc3RyaW5nO1xuICBzZWxlY3Rpb246IFRleHRSYW5nZTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdFdvcmQoeyB0ZXh0LCBzZWxlY3Rpb24gfTogVGV4dFNlY3Rpb24pOiBUZXh0UmFuZ2Uge1xuICBpZiAodGV4dCAmJiB0ZXh0Lmxlbmd0aCAmJiBzZWxlY3Rpb24uc3RhcnQgPT09IHNlbGVjdGlvbi5lbmQpIHtcbiAgICAvLyB0aGUgdXNlciBpcyBwb2ludGluZyB0byBhIHdvcmRcbiAgICByZXR1cm4gZ2V0U3Vycm91bmRpbmdXb3JkKHRleHQsIHNlbGVjdGlvbi5zdGFydCk7XG4gIH1cbiAgcmV0dXJuIHNlbGVjdGlvbjtcbn1cblxuLyoqXG4gKiAgR2V0cyB0aGUgbnVtYmVyIG9mIGxpbmUtYnJlYWtzIHRoYXQgd291bGQgaGF2ZSB0byBiZSBpbnNlcnRlZCBiZWZvcmUgdGhlIGdpdmVuICdzdGFydFBvc2l0aW9uJ1xuICogIHRvIG1ha2Ugc3VyZSB0aGVyZSdzIGFuIGVtcHR5IGxpbmUgYmV0d2VlbiAnc3RhcnRQb3NpdGlvbicgYW5kIHRoZSBwcmV2aW91cyB0ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCcmVha3NOZWVkZWRGb3JFbXB0eUxpbmVCZWZvcmUodGV4dCA9ICcnLCBzdGFydFBvc2l0aW9uOiBudW1iZXIpOiBudW1iZXIge1xuICBpZiAoc3RhcnRQb3NpdGlvbiA9PT0gMCkgcmV0dXJuIDA7XG5cbiAgLy8gcnVsZXM6XG4gIC8vIC0gSWYgd2UncmUgaW4gdGhlIGZpcnN0IGxpbmUsIG5vIGJyZWFrcyBhcmUgbmVlZGVkXG4gIC8vIC0gT3RoZXJ3aXNlIHRoZXJlIG11c3QgYmUgMiBicmVha3MgYmVmb3JlIHRoZSBwcmV2aW91cyBjaGFyYWN0ZXIuIERlcGVuZGluZyBvbiBob3cgbWFueSBicmVha3MgZXhpc3QgYWxyZWFkeSwgd2VcbiAgLy8gICAgICBtYXkgbmVlZCB0byBpbnNlcnQgMCwgMSBvciAyIGJyZWFrc1xuXG4gIGxldCBuZWVkZWRCcmVha3MgPSAyO1xuICBsZXQgaXNJbkZpcnN0TGluZSA9IHRydWU7XG4gIGZvciAobGV0IGkgPSBzdGFydFBvc2l0aW9uIC0gMTsgaSA+PSAwICYmIG5lZWRlZEJyZWFrcyA+PSAwOyBpLS0pIHtcbiAgICBzd2l0Y2ggKHRleHQuY2hhckNvZGVBdChpKSkge1xuICAgICAgY2FzZSAzMjogLy8gYmxhbmsgc3BhY2VcbiAgICAgICAgY29udGludWU7XG4gICAgICBjYXNlIDEwOiAvLyBsaW5lIGJyZWFrXG4gICAgICAgIG5lZWRlZEJyZWFrcy0tO1xuICAgICAgICBpc0luRmlyc3RMaW5lID0gZmFsc2U7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIG5lZWRlZEJyZWFrcztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGlzSW5GaXJzdExpbmUgPyAwIDogbmVlZGVkQnJlYWtzO1xufVxuXG4vKipcbiAqICBHZXRzIHRoZSBudW1iZXIgb2YgbGluZS1icmVha3MgdGhhdCB3b3VsZCBoYXZlIHRvIGJlIGluc2VydGVkIGFmdGVyIHRoZSBnaXZlbiAnc3RhcnRQb3NpdGlvbidcbiAqICB0byBtYWtlIHN1cmUgdGhlcmUncyBhbiBlbXB0eSBsaW5lIGJldHdlZW4gJ3N0YXJ0UG9zaXRpb24nIGFuZCB0aGUgbmV4dCB0ZXh0XG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBnZXRCcmVha3NOZWVkZWRGb3JFbXB0eUxpbmVBZnRlcih0ZXh0ID0gJycsIHN0YXJ0UG9zaXRpb246IG51bWJlcik6IG51bWJlciB7XG4gIGlmIChzdGFydFBvc2l0aW9uID09PSB0ZXh0Lmxlbmd0aCAtIDEpIHJldHVybiAwO1xuXG4gIC8vIHJ1bGVzOlxuICAvLyAtIElmIHdlJ3JlIGluIHRoZSBmaXJzdCBsaW5lLCBubyBicmVha3MgYXJlIG5lZWRlZFxuICAvLyAtIE90aGVyd2lzZSB0aGVyZSBtdXN0IGJlIDIgYnJlYWtzIGJlZm9yZSB0aGUgcHJldmlvdXMgY2hhcmFjdGVyLiBEZXBlbmRpbmcgb24gaG93IG1hbnkgYnJlYWtzIGV4aXN0IGFscmVhZHksIHdlXG4gIC8vICAgICAgbWF5IG5lZWQgdG8gaW5zZXJ0IDAsIDEgb3IgMiBicmVha3NcblxuICBsZXQgbmVlZGVkQnJlYWtzID0gMjtcbiAgbGV0IGlzSW5MYXN0TGluZSA9IHRydWU7XG4gIGZvciAobGV0IGkgPSBzdGFydFBvc2l0aW9uOyBpIDwgdGV4dC5sZW5ndGggJiYgbmVlZGVkQnJlYWtzID49IDA7IGkrKykge1xuICAgIHN3aXRjaCAodGV4dC5jaGFyQ29kZUF0KGkpKSB7XG4gICAgICBjYXNlIDMyOlxuICAgICAgICBjb250aW51ZTtcbiAgICAgIGNhc2UgMTA6IHtcbiAgICAgICAgbmVlZGVkQnJlYWtzLS07XG4gICAgICAgIGlzSW5MYXN0TGluZSA9IGZhbHNlO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZWVkZWRCcmVha3M7XG4gICAgfVxuICB9XG4gIHJldHVybiBpc0luTGFzdExpbmUgPyAwIDogbmVlZGVkQnJlYWtzO1xufVxuIl19