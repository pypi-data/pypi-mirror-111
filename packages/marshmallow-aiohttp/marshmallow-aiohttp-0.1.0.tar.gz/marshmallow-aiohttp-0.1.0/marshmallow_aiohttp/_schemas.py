# pylint: disable=no-self-use
# pylint: disable=unused-argument

from typing import Final

import aiohttp
import ujson
from marshmallow import Schema, fields, post_load

from ._trasers import make_default_trace_configs

DEFAULT_CLIENT_TIMEOUT: Final = aiohttp.ClientTimeout(total=60)


class TCPConnectorSchema(Schema):
    # Timout for connection reusing after releasing (optional).
    # For disabling keep-alive feature use force_close=True flag.
    keepalive_timeout = fields.Float(missing=None)

    # Total number simultaneous connections.
    # If limit is None the connector has no limit.
    limit = fields.Int(missing=100)

    # Limit simultaneous connections to the same endpoint.
    # Endpoints are the same if they are have equal host, port and is_ssl.
    # If limit is 0 the connector has no limit.
    limit_per_host = fields.Int(missing=0)

    # Some SSL servers do not properly complete SSL shutdown process,
    # in that case asyncio leaks ssl connections.
    # If this parameter is set to True, aiohttp additionally aborts
    # underlining transport after 2 seconds.
    enable_cleanup_closed = fields.Bool(missing=False)

    # Use internal cache for DNS lookups, True by default.
    use_dns_cache = fields.Bool(missing=True)

    # Expire after some seconds the DNS entries, None forever.
    ttl_dns_cache = fields.Int(missing=60 * 60)

    # Custom resolver instance to use.
    resolver = fields.Raw(missing=aiohttp.AsyncResolver)

    @post_load
    def make_connector(self, data: dict, **kwargs) -> aiohttp.TCPConnector:
        return aiohttp.TCPConnector(**data)


class ClientTimeoutSchema(Schema):
    # Total timeout for the whole request.
    total = fields.Float(
        missing=DEFAULT_CLIENT_TIMEOUT.total,
        allow_none=True,
    )

    # Total timeout for acquiring a connection from pool.
    # The time consists connection establishment for a new connection
    # or waiting for a free connection from a pool if pool connection
    # limits are exceeded.
    connect = fields.Float(
        missing=DEFAULT_CLIENT_TIMEOUT.connect,
        allow_none=True,
    )

    # A timeout for reading a portion of data from a peer.
    sock_connect = fields.Float(
        missing=DEFAULT_CLIENT_TIMEOUT.sock_connect,
        allow_none=True,
    )

    # A timeout for connecting to a peer for a new connection,
    # not given from a pool. See also connect.
    sock_read = fields.Float(
        missing=DEFAULT_CLIENT_TIMEOUT.sock_read,
        allow_none=True,
    )

    @post_load
    def make_timeout(self, data: dict, **kwargs) -> aiohttp.ClientTimeout:
        return aiohttp.ClientTimeout(**data)


class ClientSessionSchema(Schema):
    # TCP connector instance to support connection pooling (optional).
    connector = fields.Nested(
        TCPConnectorSchema,
        missing=lambda: TCPConnectorSchema().load(data={}),
    )

    # Cookies to send with the request (optional).
    cookies = fields.Dict(fields.Str, fields.Str, missing=None)

    # HTTP Headers to send with every request (optional).
    headers = fields.Dict(fields.Str, fields.Str, missing=None)

    # Set of headers for which autogenerated should be skipped (optional).
    skip_auto_headers = fields.List(fields.Str, missing=None)

    # Json serializer callable.
    json_serialize = fields.Raw(missing=lambda: ujson.dumps)

    # By default every session instance has own private cookie jar
    # for automatic cookies processing but user may redefine
    # this behavior by providing own jar implementation.
    #
    # If no cookie processing is needed, a aiohttp.DummyCookieJar
    # instance can be provided.
    cookie_jar = fields.Raw(missing=aiohttp.DummyCookieJar)

    # Close connector instance on session closing.
    connector_owner = fields.Bool(missing=True)

    # Raise an aiohttp.ClientResponseError if the response failed.
    # Do nothing for success responses (less than 400).
    raise_for_status = fields.Bool(missing=False)

    # ClientTimeout settings structure, DEFAULT_TIMEOUT by default.
    timeout = fields.Nested(
        ClientTimeoutSchema,
        missing=DEFAULT_CLIENT_TIMEOUT,
    )

    # Automatically decompress response body.
    auto_decompress = fields.Bool(missing=True)

    # Get proxies information from HTTP_PROXY / HTTPS_PROXY environment
    # variables if the parameter is True (False by default).
    trust_env = fields.Bool(missing=False)

    # A list of TraceConfig instances used for client tracing.
    # None (default) is used for request tracing disabling.
    trace_configs = fields.List(fields.Raw, missing=make_default_trace_configs)

    @post_load
    def make_session(self, data: dict, **kwargs) -> aiohttp.ClientSession:
        return aiohttp.ClientSession(**data)
