# Copyright: Ankitects Pty Ltd and contributors
# License: GNU AGPL, version 3 or later; http://www.gnu.org/licenses/agpl.html
# pylint: skip-file

from __future__ import annotations

"""
THIS FILE IS AUTOMATICALLY GENERATED - DO NOT EDIT.

Please do not access methods on the backend directly - they may be changed
or removed at any time. Instead, please use the methods on the collection
instead. Eg, don't use col.backend.all_deck_config(), instead use
col.decks.all_config()
"""
    
from typing import *

import anki._backend.backend_pb2 as pb

class RustBackendGenerated:
    def _run_command(self, service: int, method: int, input: Any) -> bytes:
        raise Exception("not implemented")
    
    def sched_timing_today(self) -> pb.SchedTimingTodayResponse:
        input = pb.Empty()
        output = pb.SchedTimingTodayResponse()
        output.ParseFromString(self._run_command(0, 0, input))
        return output

    def studied_today(self) -> str:
        input = pb.Empty()
        output = pb.String()
        output.ParseFromString(self._run_command(0, 1, input))
        return output.val

    def studied_today_message(self, *, cards: int, seconds: float) -> str:
        input = pb.StudiedTodayMessageRequest(cards=cards, seconds=seconds)
        output = pb.String()
        output.ParseFromString(self._run_command(0, 2, input))
        return output.val

    def update_stats(self, *, deck_id: int, new_delta: int, review_delta: int, millisecond_delta: int) -> pb.Empty:
        input = pb.UpdateStatsRequest(deck_id=deck_id, new_delta=new_delta, review_delta=review_delta, millisecond_delta=millisecond_delta)
        output = pb.Empty()
        output.ParseFromString(self._run_command(0, 3, input))
        return output

    def extend_limits(self, *, deck_id: int, new_delta: int, review_delta: int) -> pb.Empty:
        input = pb.ExtendLimitsRequest(deck_id=deck_id, new_delta=new_delta, review_delta=review_delta)
        output = pb.Empty()
        output.ParseFromString(self._run_command(0, 4, input))
        return output

    def counts_for_deck_today(self, did: int) -> pb.CountsForDeckTodayResponse:
        input = pb.DeckId(did=did)
        output = pb.CountsForDeckTodayResponse()
        output.ParseFromString(self._run_command(0, 5, input))
        return output

    def congrats_info(self) -> pb.CongratsInfoResponse:
        input = pb.Empty()
        output = pb.CongratsInfoResponse()
        output.ParseFromString(self._run_command(0, 6, input))
        return output

    def restore_buried_and_suspended_cards(self, cids: Sequence[int]) -> pb.OpChanges:
        input = pb.CardIds(cids=cids)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(0, 7, input))
        return output

    def unbury_deck(self, *, deck_id: int, mode: pb.UnburyDeckRequest.Mode.V) -> pb.OpChanges:
        input = pb.UnburyDeckRequest(deck_id=deck_id, mode=mode)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(0, 8, input))
        return output

    def bury_or_suspend_cards(self, *, card_ids: Sequence[int], note_ids: Sequence[int], mode: pb.BuryOrSuspendCardsRequest.Mode.V) -> pb.OpChangesWithCount:
        input = pb.BuryOrSuspendCardsRequest(card_ids=card_ids, note_ids=note_ids, mode=mode)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(0, 9, input))
        return output

    def empty_filtered_deck(self, did: int) -> pb.OpChanges:
        input = pb.DeckId(did=did)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(0, 10, input))
        return output

    def rebuild_filtered_deck(self, did: int) -> pb.OpChangesWithCount:
        input = pb.DeckId(did=did)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(0, 11, input))
        return output

    def schedule_cards_as_new(self, *, card_ids: Sequence[int], log: bool) -> pb.OpChanges:
        input = pb.ScheduleCardsAsNewRequest(card_ids=card_ids, log=log)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(0, 12, input))
        return output

    def set_due_date(self, *, card_ids: Sequence[int], days: str, config_key: pb.Config.String) -> pb.OpChanges:
        input = pb.SetDueDateRequest(card_ids=card_ids, days=days, config_key=config_key)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(0, 13, input))
        return output

    def sort_cards(self, *, card_ids: Sequence[int], starting_from: int, step_size: int, randomize: bool, shift_existing: bool) -> pb.OpChangesWithCount:
        input = pb.SortCardsRequest(card_ids=card_ids, starting_from=starting_from, step_size=step_size, randomize=randomize, shift_existing=shift_existing)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(0, 14, input))
        return output

    def sort_deck(self, *, deck_id: int, randomize: bool) -> pb.OpChangesWithCount:
        input = pb.SortDeckRequest(deck_id=deck_id, randomize=randomize)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(0, 15, input))
        return output

    def get_next_card_states(self, cid: int) -> pb.NextCardStates:
        input = pb.CardId(cid=cid)
        output = pb.NextCardStates()
        output.ParseFromString(self._run_command(0, 16, input))
        return output

    def describe_next_states(self, input: pb.NextCardStates) -> Sequence[str]:
        output = pb.StringList()
        output.ParseFromString(self._run_command(0, 17, input))
        return output.vals

    def state_is_leech(self, input: pb.SchedulingState) -> bool:
        output = pb.Bool()
        output.ParseFromString(self._run_command(0, 18, input))
        return output.val

    def answer_card(self, input: pb.CardAnswer) -> pb.OpChanges:
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(0, 19, input))
        return output

    def upgrade_scheduler(self) -> pb.Empty:
        input = pb.Empty()
        output = pb.Empty()
        output.ParseFromString(self._run_command(0, 20, input))
        return output

    def get_queued_cards(self, *, fetch_limit: int, intraday_learning_only: bool) -> pb.QueuedCards:
        input = pb.GetQueuedCardsRequest(fetch_limit=fetch_limit, intraday_learning_only=intraday_learning_only)
        output = pb.QueuedCards()
        output.ParseFromString(self._run_command(0, 21, input))
        return output

    def add_deck_legacy(self, json: bytes) -> pb.OpChangesWithId:
        input = pb.Json(json=json)
        output = pb.OpChangesWithId()
        output.ParseFromString(self._run_command(1, 0, input))
        return output

    def add_or_update_deck_legacy(self, *, deck: bytes, preserve_usn_and_mtime: bool) -> int:
        input = pb.AddOrUpdateDeckLegacyRequest(deck=deck, preserve_usn_and_mtime=preserve_usn_and_mtime)
        output = pb.DeckId()
        output.ParseFromString(self._run_command(1, 1, input))
        return output.did

    def deck_tree(self, *, now: int, top_deck_id: int) -> pb.DeckTreeNode:
        input = pb.DeckTreeRequest(now=now, top_deck_id=top_deck_id)
        output = pb.DeckTreeNode()
        output.ParseFromString(self._run_command(1, 2, input))
        return output

    def deck_tree_legacy(self) -> bytes:
        input = pb.Empty()
        output = pb.Json()
        output.ParseFromString(self._run_command(1, 3, input))
        return output.json

    def get_all_decks_legacy(self) -> bytes:
        input = pb.Empty()
        output = pb.Json()
        output.ParseFromString(self._run_command(1, 4, input))
        return output.json

    def get_deck_id_by_name(self, val: str) -> int:
        input = pb.String(val=val)
        output = pb.DeckId()
        output.ParseFromString(self._run_command(1, 5, input))
        return output.did

    def get_deck(self, did: int) -> pb.Deck:
        input = pb.DeckId(did=did)
        output = pb.Deck()
        output.ParseFromString(self._run_command(1, 6, input))
        return output

    def update_deck(self, input: pb.Deck) -> pb.OpChanges:
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(1, 7, input))
        return output

    def update_deck_legacy(self, json: bytes) -> pb.OpChanges:
        input = pb.Json(json=json)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(1, 8, input))
        return output

    def set_deck_collapsed(self, *, deck_id: int, collapsed: bool, scope: pb.SetDeckCollapsedRequest.Scope.V) -> pb.OpChanges:
        input = pb.SetDeckCollapsedRequest(deck_id=deck_id, collapsed=collapsed, scope=scope)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(1, 9, input))
        return output

    def get_deck_legacy(self, did: int) -> bytes:
        input = pb.DeckId(did=did)
        output = pb.Json()
        output.ParseFromString(self._run_command(1, 10, input))
        return output.json

    def get_deck_names(self, *, skip_empty_default: bool, include_filtered: bool) -> Sequence[pb.DeckNameId]:
        input = pb.GetDeckNamesRequest(skip_empty_default=skip_empty_default, include_filtered=include_filtered)
        output = pb.DeckNames()
        output.ParseFromString(self._run_command(1, 11, input))
        return output.entries

    def new_deck_legacy(self, val: bool) -> bytes:
        input = pb.Bool(val=val)
        output = pb.Json()
        output.ParseFromString(self._run_command(1, 12, input))
        return output.json

    def remove_decks(self, dids: Sequence[int]) -> pb.OpChangesWithCount:
        input = pb.DeckIds(dids=dids)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(1, 13, input))
        return output

    def reparent_decks(self, *, deck_ids: Sequence[int], new_parent: int) -> pb.OpChangesWithCount:
        input = pb.ReparentDecksRequest(deck_ids=deck_ids, new_parent=new_parent)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(1, 14, input))
        return output

    def rename_deck(self, *, deck_id: int, new_name: str) -> pb.OpChanges:
        input = pb.RenameDeckRequest(deck_id=deck_id, new_name=new_name)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(1, 15, input))
        return output

    def get_or_create_filtered_deck(self, did: int) -> pb.FilteredDeckForUpdate:
        input = pb.DeckId(did=did)
        output = pb.FilteredDeckForUpdate()
        output.ParseFromString(self._run_command(1, 16, input))
        return output

    def add_or_update_filtered_deck(self, input: pb.FilteredDeckForUpdate) -> pb.OpChangesWithId:
        output = pb.OpChangesWithId()
        output.ParseFromString(self._run_command(1, 17, input))
        return output

    def filtered_deck_order_labels(self) -> Sequence[str]:
        input = pb.Empty()
        output = pb.StringList()
        output.ParseFromString(self._run_command(1, 18, input))
        return output.vals

    def set_current_deck(self, did: int) -> pb.OpChanges:
        input = pb.DeckId(did=did)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(1, 19, input))
        return output

    def get_current_deck(self) -> pb.Deck:
        input = pb.Empty()
        output = pb.Deck()
        output.ParseFromString(self._run_command(1, 20, input))
        return output

    def new_note(self, ntid: int) -> pb.Note:
        input = pb.NotetypeId(ntid=ntid)
        output = pb.Note()
        output.ParseFromString(self._run_command(2, 0, input))
        return output

    def add_note(self, *, note: pb.Note, deck_id: int) -> pb.AddNoteResponse:
        input = pb.AddNoteRequest(note=note, deck_id=deck_id)
        output = pb.AddNoteResponse()
        output.ParseFromString(self._run_command(2, 1, input))
        return output

    def defaults_for_adding(self, home_deck_of_current_review_card: int) -> pb.DeckAndNotetype:
        input = pb.DefaultsForAddingRequest(home_deck_of_current_review_card=home_deck_of_current_review_card)
        output = pb.DeckAndNotetype()
        output.ParseFromString(self._run_command(2, 2, input))
        return output

    def default_deck_for_notetype(self, ntid: int) -> int:
        input = pb.NotetypeId(ntid=ntid)
        output = pb.DeckId()
        output.ParseFromString(self._run_command(2, 3, input))
        return output.did

    def update_note(self, *, note: pb.Note, skip_undo_entry: bool) -> pb.OpChanges:
        input = pb.UpdateNoteRequest(note=note, skip_undo_entry=skip_undo_entry)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(2, 4, input))
        return output

    def get_note(self, nid: int) -> pb.Note:
        input = pb.NoteId(nid=nid)
        output = pb.Note()
        output.ParseFromString(self._run_command(2, 5, input))
        return output

    def remove_notes(self, *, note_ids: Sequence[int], card_ids: Sequence[int]) -> pb.OpChangesWithCount:
        input = pb.RemoveNotesRequest(note_ids=note_ids, card_ids=card_ids)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(2, 6, input))
        return output

    def cloze_numbers_in_note(self, input: pb.Note) -> Sequence[int]:
        output = pb.ClozeNumbersInNoteResponse()
        output.ParseFromString(self._run_command(2, 7, input))
        return output.numbers

    def after_note_updates(self, *, nids: Sequence[int], mark_notes_modified: bool, generate_cards: bool) -> pb.OpChangesWithCount:
        input = pb.AfterNoteUpdatesRequest(nids=nids, mark_notes_modified=mark_notes_modified, generate_cards=generate_cards)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(2, 8, input))
        return output

    def field_names_for_notes(self, nids: Sequence[int]) -> Sequence[str]:
        input = pb.FieldNamesForNotesRequest(nids=nids)
        output = pb.FieldNamesForNotesResponse()
        output.ParseFromString(self._run_command(2, 9, input))
        return output.fields

    def note_fields_check(self, input: pb.Note) -> pb.NoteFieldsCheckResponse:
        output = pb.NoteFieldsCheckResponse()
        output.ParseFromString(self._run_command(2, 10, input))
        return output

    def cards_of_note(self, nid: int) -> Sequence[int]:
        input = pb.NoteId(nid=nid)
        output = pb.CardIds()
        output.ParseFromString(self._run_command(2, 11, input))
        return output.cids

    def sync_media(self, input: pb.SyncAuth) -> pb.Empty:
        output = pb.Empty()
        output.ParseFromString(self._run_command(3, 0, input))
        return output

    def abort_sync(self) -> pb.Empty:
        input = pb.Empty()
        output = pb.Empty()
        output.ParseFromString(self._run_command(3, 1, input))
        return output

    def abort_media_sync(self) -> pb.Empty:
        input = pb.Empty()
        output = pb.Empty()
        output.ParseFromString(self._run_command(3, 2, input))
        return output

    def before_upload(self) -> pb.Empty:
        input = pb.Empty()
        output = pb.Empty()
        output.ParseFromString(self._run_command(3, 3, input))
        return output

    def sync_login(self, *, username: str, password: str) -> pb.SyncAuth:
        input = pb.SyncLoginRequest(username=username, password=password)
        output = pb.SyncAuth()
        output.ParseFromString(self._run_command(3, 4, input))
        return output

    def sync_status(self, input: pb.SyncAuth) -> pb.SyncStatusResponse:
        output = pb.SyncStatusResponse()
        output.ParseFromString(self._run_command(3, 5, input))
        return output

    def sync_collection(self, input: pb.SyncAuth) -> pb.SyncCollectionResponse:
        output = pb.SyncCollectionResponse()
        output.ParseFromString(self._run_command(3, 6, input))
        return output

    def full_upload(self, input: pb.SyncAuth) -> pb.Empty:
        output = pb.Empty()
        output.ParseFromString(self._run_command(3, 7, input))
        return output

    def full_download(self, input: pb.SyncAuth) -> pb.Empty:
        output = pb.Empty()
        output.ParseFromString(self._run_command(3, 8, input))
        return output

    def sync_server_method(self, *, method: pb.SyncServerMethodRequest.Method.V, data: bytes) -> bytes:
        input = pb.SyncServerMethodRequest(method=method, data=data)
        output = pb.Json()
        output.ParseFromString(self._run_command(3, 9, input))
        return output.json

    def add_notetype(self, input: pb.Notetype) -> pb.OpChangesWithId:
        output = pb.OpChangesWithId()
        output.ParseFromString(self._run_command(4, 0, input))
        return output

    def update_notetype(self, input: pb.Notetype) -> pb.OpChanges:
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(4, 1, input))
        return output

    def add_notetype_legacy(self, json: bytes) -> pb.OpChangesWithId:
        input = pb.Json(json=json)
        output = pb.OpChangesWithId()
        output.ParseFromString(self._run_command(4, 2, input))
        return output

    def update_notetype_legacy(self, json: bytes) -> pb.OpChanges:
        input = pb.Json(json=json)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(4, 3, input))
        return output

    def add_or_update_notetype(self, *, json: bytes, preserve_usn_and_mtime: bool) -> int:
        input = pb.AddOrUpdateNotetypeRequest(json=json, preserve_usn_and_mtime=preserve_usn_and_mtime)
        output = pb.NotetypeId()
        output.ParseFromString(self._run_command(4, 4, input))
        return output.ntid

    def get_stock_notetype_legacy(self, kind: pb.StockNotetype.Kind.V) -> bytes:
        input = pb.StockNotetype(kind=kind)
        output = pb.Json()
        output.ParseFromString(self._run_command(4, 5, input))
        return output.json

    def get_notetype(self, ntid: int) -> pb.Notetype:
        input = pb.NotetypeId(ntid=ntid)
        output = pb.Notetype()
        output.ParseFromString(self._run_command(4, 6, input))
        return output

    def get_notetype_legacy(self, ntid: int) -> bytes:
        input = pb.NotetypeId(ntid=ntid)
        output = pb.Json()
        output.ParseFromString(self._run_command(4, 7, input))
        return output.json

    def get_notetype_names(self) -> Sequence[pb.NotetypeNameId]:
        input = pb.Empty()
        output = pb.NotetypeNames()
        output.ParseFromString(self._run_command(4, 8, input))
        return output.entries

    def get_notetype_names_and_counts(self) -> Sequence[pb.NotetypeNameIdUseCount]:
        input = pb.Empty()
        output = pb.NotetypeUseCounts()
        output.ParseFromString(self._run_command(4, 9, input))
        return output.entries

    def get_notetype_id_by_name(self, val: str) -> int:
        input = pb.String(val=val)
        output = pb.NotetypeId()
        output.ParseFromString(self._run_command(4, 10, input))
        return output.ntid

    def remove_notetype(self, ntid: int) -> pb.OpChanges:
        input = pb.NotetypeId(ntid=ntid)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(4, 11, input))
        return output

    def get_aux_notetype_config_key(self, *, id: int, key: str) -> str:
        input = pb.GetAuxConfigKeyRequest(id=id, key=key)
        output = pb.String()
        output.ParseFromString(self._run_command(4, 12, input))
        return output.val

    def get_aux_template_config_key(self, *, notetype_id: int, card_ordinal: int, key: str) -> str:
        input = pb.GetAuxTemplateConfigKeyRequest(notetype_id=notetype_id, card_ordinal=card_ordinal, key=key)
        output = pb.String()
        output.ParseFromString(self._run_command(4, 13, input))
        return output.val

    def get_single_notetype_of_notes(self, note_ids: Sequence[int]) -> int:
        input = pb.NoteIds(note_ids=note_ids)
        output = pb.NotetypeId()
        output.ParseFromString(self._run_command(4, 14, input))
        return output.ntid

    def get_change_notetype_info(self, *, old_notetype_id: int, new_notetype_id: int) -> bytes:
        input = pb.GetChangeNotetypeInfoRequest(old_notetype_id=old_notetype_id, new_notetype_id=new_notetype_id)
        return self._run_command(4, 15, input)

    def change_notetype(self, input: pb.ChangeNotetypeRequest) -> pb.OpChanges:
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(4, 16, input))
        return output

    def get_config_json(self, val: str) -> bytes:
        input = pb.String(val=val)
        output = pb.Json()
        output.ParseFromString(self._run_command(5, 0, input))
        return output.json

    def set_config_json(self, *, key: str, value_json: bytes, undoable: bool) -> pb.OpChanges:
        input = pb.SetConfigJsonRequest(key=key, value_json=value_json, undoable=undoable)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(5, 1, input))
        return output

    def set_config_json_no_undo(self, *, key: str, value_json: bytes, undoable: bool) -> pb.Empty:
        input = pb.SetConfigJsonRequest(key=key, value_json=value_json, undoable=undoable)
        output = pb.Empty()
        output.ParseFromString(self._run_command(5, 2, input))
        return output

    def remove_config(self, val: str) -> pb.OpChanges:
        input = pb.String(val=val)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(5, 3, input))
        return output

    def get_all_config(self) -> bytes:
        input = pb.Empty()
        output = pb.Json()
        output.ParseFromString(self._run_command(5, 4, input))
        return output.json

    def get_config_bool(self, key: pb.Config.Bool.Key.V) -> bool:
        input = pb.Config.Bool(key=key)
        output = pb.Bool()
        output.ParseFromString(self._run_command(5, 5, input))
        return output.val

    def set_config_bool(self, *, key: pb.Config.Bool.Key.V, value: bool, undoable: bool) -> pb.OpChanges:
        input = pb.SetConfigBoolRequest(key=key, value=value, undoable=undoable)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(5, 6, input))
        return output

    def get_config_string(self, key: pb.Config.String.Key.V) -> str:
        input = pb.Config.String(key=key)
        output = pb.String()
        output.ParseFromString(self._run_command(5, 7, input))
        return output.val

    def set_config_string(self, *, key: pb.Config.String.Key.V, value: str, undoable: bool) -> pb.OpChanges:
        input = pb.SetConfigStringRequest(key=key, value=value, undoable=undoable)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(5, 8, input))
        return output

    def get_preferences(self) -> pb.Preferences:
        input = pb.Empty()
        output = pb.Preferences()
        output.ParseFromString(self._run_command(5, 9, input))
        return output

    def set_preferences(self, input: pb.Preferences) -> pb.OpChanges:
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(5, 10, input))
        return output

    def extract_av_tags(self, *, text: str, question_side: bool) -> pb.ExtractAVTagsResponse:
        input = pb.ExtractAVTagsRequest(text=text, question_side=question_side)
        output = pb.ExtractAVTagsResponse()
        output.ParseFromString(self._run_command(6, 0, input))
        return output

    def extract_latex(self, *, text: str, svg: bool, expand_clozes: bool) -> pb.ExtractLatexResponse:
        input = pb.ExtractLatexRequest(text=text, svg=svg, expand_clozes=expand_clozes)
        output = pb.ExtractLatexResponse()
        output.ParseFromString(self._run_command(6, 1, input))
        return output

    def get_empty_cards(self) -> pb.EmptyCardsReport:
        input = pb.Empty()
        output = pb.EmptyCardsReport()
        output.ParseFromString(self._run_command(6, 2, input))
        return output

    def render_existing_card(self, *, card_id: int, browser: bool) -> pb.RenderCardResponse:
        input = pb.RenderExistingCardRequest(card_id=card_id, browser=browser)
        output = pb.RenderCardResponse()
        output.ParseFromString(self._run_command(6, 3, input))
        return output

    def render_uncommitted_card(self, *, note: pb.Note, card_ord: int, template: pb.Notetype.Template, fill_empty: bool) -> pb.RenderCardResponse:
        input = pb.RenderUncommittedCardRequest(note=note, card_ord=card_ord, template=template, fill_empty=fill_empty)
        output = pb.RenderCardResponse()
        output.ParseFromString(self._run_command(6, 4, input))
        return output

    def render_uncommitted_card_legacy(self, *, note: pb.Note, card_ord: int, template: bytes, fill_empty: bool) -> pb.RenderCardResponse:
        input = pb.RenderUncommittedCardLegacyRequest(note=note, card_ord=card_ord, template=template, fill_empty=fill_empty)
        output = pb.RenderCardResponse()
        output.ParseFromString(self._run_command(6, 5, input))
        return output

    def strip_av_tags(self, val: str) -> str:
        input = pb.String(val=val)
        output = pb.String()
        output.ParseFromString(self._run_command(6, 6, input))
        return output.val

    def render_markdown(self, *, markdown: str, sanitize: bool) -> str:
        input = pb.RenderMarkdownRequest(markdown=markdown, sanitize=sanitize)
        output = pb.String()
        output.ParseFromString(self._run_command(6, 7, input))
        return output.val

    def add_or_update_deck_config_legacy(self, json: bytes) -> int:
        input = pb.Json(json=json)
        output = pb.DeckConfigId()
        output.ParseFromString(self._run_command(7, 0, input))
        return output.dcid

    def get_deck_config(self, dcid: int) -> pb.DeckConfig:
        input = pb.DeckConfigId(dcid=dcid)
        output = pb.DeckConfig()
        output.ParseFromString(self._run_command(7, 1, input))
        return output

    def all_deck_config_legacy(self) -> bytes:
        input = pb.Empty()
        output = pb.Json()
        output.ParseFromString(self._run_command(7, 2, input))
        return output.json

    def get_deck_config_legacy(self, dcid: int) -> bytes:
        input = pb.DeckConfigId(dcid=dcid)
        output = pb.Json()
        output.ParseFromString(self._run_command(7, 3, input))
        return output.json

    def new_deck_config_legacy(self) -> bytes:
        input = pb.Empty()
        output = pb.Json()
        output.ParseFromString(self._run_command(7, 4, input))
        return output.json

    def remove_deck_config(self, dcid: int) -> pb.Empty:
        input = pb.DeckConfigId(dcid=dcid)
        output = pb.Empty()
        output.ParseFromString(self._run_command(7, 5, input))
        return output

    def get_deck_configs_for_update(self, did: int) -> pb.DeckConfigsForUpdate:
        input = pb.DeckId(did=did)
        output = pb.DeckConfigsForUpdate()
        output.ParseFromString(self._run_command(7, 6, input))
        return output

    def update_deck_configs(self, input: pb.UpdateDeckConfigsRequest) -> pb.OpChanges:
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(7, 7, input))
        return output

    def clear_unused_tags(self) -> pb.OpChangesWithCount:
        input = pb.Empty()
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 0, input))
        return output

    def all_tags(self) -> Sequence[str]:
        input = pb.Empty()
        output = pb.StringList()
        output.ParseFromString(self._run_command(8, 1, input))
        return output.vals

    def remove_tags(self, val: str) -> pb.OpChangesWithCount:
        input = pb.String(val=val)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 2, input))
        return output

    def set_tag_collapsed(self, *, name: str, collapsed: bool) -> pb.OpChanges:
        input = pb.SetTagCollapsedRequest(name=name, collapsed=collapsed)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(8, 3, input))
        return output

    def tag_tree(self) -> pb.TagTreeNode:
        input = pb.Empty()
        output = pb.TagTreeNode()
        output.ParseFromString(self._run_command(8, 4, input))
        return output

    def reparent_tags(self, *, tags: Sequence[str], new_parent: str) -> pb.OpChangesWithCount:
        input = pb.ReparentTagsRequest(tags=tags, new_parent=new_parent)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 5, input))
        return output

    def rename_tags(self, *, current_prefix: str, new_prefix: str) -> pb.OpChangesWithCount:
        input = pb.RenameTagsRequest(current_prefix=current_prefix, new_prefix=new_prefix)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 6, input))
        return output

    def add_note_tags(self, *, note_ids: Sequence[int], tags: str) -> pb.OpChangesWithCount:
        input = pb.NoteIdsAndTagsRequest(note_ids=note_ids, tags=tags)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 7, input))
        return output

    def remove_note_tags(self, *, note_ids: Sequence[int], tags: str) -> pb.OpChangesWithCount:
        input = pb.NoteIdsAndTagsRequest(note_ids=note_ids, tags=tags)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 8, input))
        return output

    def find_and_replace_tag(self, *, note_ids: Sequence[int], search: str, replacement: str, regex: bool, match_case: bool) -> pb.OpChangesWithCount:
        input = pb.FindAndReplaceTagRequest(note_ids=note_ids, search=search, replacement=replacement, regex=regex, match_case=match_case)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(8, 9, input))
        return output

    def build_search_string(self, input: pb.SearchNode) -> str:
        output = pb.String()
        output.ParseFromString(self._run_command(9, 0, input))
        return output.val

    def search_cards(self, *, search: str, order: pb.SortOrder) -> Sequence[int]:
        input = pb.SearchRequest(search=search, order=order)
        output = pb.SearchResponse()
        output.ParseFromString(self._run_command(9, 1, input))
        return output.ids

    def search_notes(self, *, search: str, order: pb.SortOrder) -> Sequence[int]:
        input = pb.SearchRequest(search=search, order=order)
        output = pb.SearchResponse()
        output.ParseFromString(self._run_command(9, 2, input))
        return output.ids

    def join_search_nodes(self, *, joiner: pb.SearchNode.Group.Joiner.V, existing_node: pb.SearchNode, additional_node: pb.SearchNode) -> str:
        input = pb.JoinSearchNodesRequest(joiner=joiner, existing_node=existing_node, additional_node=additional_node)
        output = pb.String()
        output.ParseFromString(self._run_command(9, 3, input))
        return output.val

    def replace_search_node(self, *, existing_node: pb.SearchNode, replacement_node: pb.SearchNode) -> str:
        input = pb.ReplaceSearchNodeRequest(existing_node=existing_node, replacement_node=replacement_node)
        output = pb.String()
        output.ParseFromString(self._run_command(9, 4, input))
        return output.val

    def find_and_replace(self, *, nids: Sequence[int], search: str, replacement: str, regex: bool, match_case: bool, field_name: str) -> pb.OpChangesWithCount:
        input = pb.FindAndReplaceRequest(nids=nids, search=search, replacement=replacement, regex=regex, match_case=match_case, field_name=field_name)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(9, 5, input))
        return output

    def all_browser_columns(self) -> Sequence[pb.BrowserColumns.Column]:
        input = pb.Empty()
        output = pb.BrowserColumns()
        output.ParseFromString(self._run_command(9, 6, input))
        return output.columns

    def browser_row_for_id(self, val: int) -> pb.BrowserRow:
        input = pb.Int64(val=val)
        output = pb.BrowserRow()
        output.ParseFromString(self._run_command(9, 7, input))
        return output

    def set_active_browser_columns(self, vals: Sequence[str]) -> pb.Empty:
        input = pb.StringList(vals=vals)
        output = pb.Empty()
        output.ParseFromString(self._run_command(9, 8, input))
        return output

    def card_stats(self, cid: int) -> str:
        input = pb.CardId(cid=cid)
        output = pb.String()
        output.ParseFromString(self._run_command(10, 0, input))
        return output.val

    def graphs(self, *, search: str, days: int) -> bytes:
        input = pb.GraphsRequest(search=search, days=days)
        return self._run_command(10, 1, input)

    def get_graph_preferences(self) -> bytes:
        input = pb.Empty()
        return self._run_command(10, 2, input)

    def set_graph_preferences(self, input: pb.GraphPreferences) -> pb.Empty:
        output = pb.Empty()
        output.ParseFromString(self._run_command(10, 3, input))
        return output

    def check_media(self) -> pb.CheckMediaResponse:
        input = pb.Empty()
        output = pb.CheckMediaResponse()
        output.ParseFromString(self._run_command(11, 0, input))
        return output

    def trash_media_files(self, fnames: Sequence[str]) -> pb.Empty:
        input = pb.TrashMediaFilesRequest(fnames=fnames)
        output = pb.Empty()
        output.ParseFromString(self._run_command(11, 1, input))
        return output

    def add_media_file(self, *, desired_name: str, data: bytes) -> str:
        input = pb.AddMediaFileRequest(desired_name=desired_name, data=data)
        output = pb.String()
        output.ParseFromString(self._run_command(11, 2, input))
        return output.val

    def empty_trash(self) -> pb.Empty:
        input = pb.Empty()
        output = pb.Empty()
        output.ParseFromString(self._run_command(11, 3, input))
        return output

    def restore_trash(self) -> pb.Empty:
        input = pb.Empty()
        output = pb.Empty()
        output.ParseFromString(self._run_command(11, 4, input))
        return output

    def translate_string(self, input: pb.TranslateStringRequest) -> str:
        output = pb.String()
        output.ParseFromString(self._run_command(12, 0, input))
        return output.val

    def format_timespan(self, *, seconds: float, context: pb.FormatTimespanRequest.Context.V) -> str:
        input = pb.FormatTimespanRequest(seconds=seconds, context=context)
        output = pb.String()
        output.ParseFromString(self._run_command(12, 1, input))
        return output.val

    def i18n_resources(self, modules: Sequence[str]) -> bytes:
        input = pb.I18nResourcesRequest(modules=modules)
        output = pb.Json()
        output.ParseFromString(self._run_command(12, 2, input))
        return output.json

    def open_collection(self, *, collection_path: str, media_folder_path: str, media_db_path: str, log_path: str) -> pb.Empty:
        input = pb.OpenCollectionRequest(collection_path=collection_path, media_folder_path=media_folder_path, media_db_path=media_db_path, log_path=log_path)
        output = pb.Empty()
        output.ParseFromString(self._run_command(13, 0, input))
        return output

    def close_collection(self, downgrade_to_schema11: bool) -> pb.Empty:
        input = pb.CloseCollectionRequest(downgrade_to_schema11=downgrade_to_schema11)
        output = pb.Empty()
        output.ParseFromString(self._run_command(13, 1, input))
        return output

    def check_database(self) -> Sequence[str]:
        input = pb.Empty()
        output = pb.CheckDatabaseResponse()
        output.ParseFromString(self._run_command(13, 2, input))
        return output.problems

    def get_undo_status(self) -> pb.UndoStatus:
        input = pb.Empty()
        output = pb.UndoStatus()
        output.ParseFromString(self._run_command(13, 3, input))
        return output

    def undo(self) -> pb.OpChangesAfterUndo:
        input = pb.Empty()
        output = pb.OpChangesAfterUndo()
        output.ParseFromString(self._run_command(13, 4, input))
        return output

    def redo(self) -> pb.OpChangesAfterUndo:
        input = pb.Empty()
        output = pb.OpChangesAfterUndo()
        output.ParseFromString(self._run_command(13, 5, input))
        return output

    def add_custom_undo_entry(self, val: str) -> int:
        input = pb.String(val=val)
        output = pb.UInt32()
        output.ParseFromString(self._run_command(13, 6, input))
        return output.val

    def merge_undo_entries(self, val: int) -> pb.OpChanges:
        input = pb.UInt32(val=val)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(13, 7, input))
        return output

    def latest_progress(self) -> pb.Progress:
        input = pb.Empty()
        output = pb.Progress()
        output.ParseFromString(self._run_command(13, 8, input))
        return output

    def set_wants_abort(self) -> pb.Empty:
        input = pb.Empty()
        output = pb.Empty()
        output.ParseFromString(self._run_command(13, 9, input))
        return output

    def get_card(self, cid: int) -> pb.Card:
        input = pb.CardId(cid=cid)
        output = pb.Card()
        output.ParseFromString(self._run_command(14, 0, input))
        return output

    def update_card(self, *, card: pb.Card, skip_undo_entry: bool) -> pb.OpChanges:
        input = pb.UpdateCardRequest(card=card, skip_undo_entry=skip_undo_entry)
        output = pb.OpChanges()
        output.ParseFromString(self._run_command(14, 1, input))
        return output

    def remove_cards(self, card_ids: Sequence[int]) -> pb.Empty:
        input = pb.RemoveCardsRequest(card_ids=card_ids)
        output = pb.Empty()
        output.ParseFromString(self._run_command(14, 2, input))
        return output

    def set_deck(self, *, card_ids: Sequence[int], deck_id: int) -> pb.OpChangesWithCount:
        input = pb.SetDeckRequest(card_ids=card_ids, deck_id=deck_id)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(14, 3, input))
        return output

    def set_flag(self, *, card_ids: Sequence[int], flag: int) -> pb.OpChangesWithCount:
        input = pb.SetFlagRequest(card_ids=card_ids, flag=flag)
        output = pb.OpChangesWithCount()
        output.ParseFromString(self._run_command(14, 4, input))
        return output
